官網信用卡線上繳費

將客戶有投保的保單全部匯集成一個交易序號統一繳費

交易序號 -> 可能裡面有三個繳費號碼或保單號碼(強制、任意...) -> 三個繳費號碼對應各自的保單

統整成交易序號的部分振華會處理

我這邊預計完成四個頁面(RWD)
MBC3PF

做在網投系統裡，直接在上方選單新增繳費服務，需要登入後才能使用此功能，登入後才有USERID，才能串資料

第一頁可參考KYC保費管理系統-線上繳費作業的欄位

第二三頁可參考KYC首頁->左下->信用卡授權申請器來做

第三頁確認請款去CALL HITRUST的API，成功與否跳回第四頁顯示(此階段取授權成功要一起添加請款註記)

-------------------------------------------------------------------------------------------------

1.在function.jsp增加繳費服務功能，之後再去新增STRUSTS路徑
2.進入點：先判斷是否有登入，有登入->進入第一頁，未登入->送到登入畫面

可能這樣判斷
UserInfo ui = (UserInfo) session.getAttribute(GlobalKey.USER_INFO);

3.第一頁顯示未繳費的交易序號明細
checkbox 設定name固定一致，ID取固定名稱+流水號，onclick呼叫JS ，VAULE為交易序號   保費欄位的NAME放交易序號

<table>
    <tr>                                                                           交易序號                                           交易序號
	    <td><input type="checkbox" id=<%=ckb+String.valueOf(i+1)%> name="ckb" value="a123" onclick="calculate(this.id)" ></td><td name="a123">200</td>
    </tr>
    <tr>             
    	<td><input type="checkbox" id="f2" name="ckb" value="a123" onclick="calculate(this.id)" ></td><td name="a123">500</td>
    </tr>
    <tr>
    	<td><input type="checkbox" id="f3" name="ckb" value="c789" onclick="calculate(this.id)" ></td><td name="c789">100</td>
    </tr> 	
    
</table>

交易序號：<input type="text" id="tradecode" name="tradecode" value="" disabled><br>
應收總保費：<input type="text" id="instotal" name="instotal" value="" disabled><br>

<button class="btn btn-lg" type="button" style="background-color:red"><a href="http://www.firstins.com.tw" target="_blank" style="color:white;text-decoration: none">回官網首頁</a></button> 
<button class="btn btn-lg" type="button" onclick="process(5);" id="next" disabled>信用卡繳費 </button>

//id是這個勾選的checkbox的id
function calculate(id){

	if($('#'+id).prop("checked")){
		//name叫做agreeChk1的全部都disabled
		$("input[name='ckb']").each(function(){
			$(this).prop("disabled",true);
		})
		//選取到的這個checkbox打開
		$('#'+id).prop("disabled",false);
		//讓信用卡繳費disable取消
		$('#next').prop("disabled",false);
		//交易序號，同時也是各項保費的NAME
		var tradecode=$('#'+id).val();
		//計算總保費
		var total=0;			
		//取得保費欄位是該交易序號的總數
		var len=document.getElementsByName(tradecode).length;

		for(var i=0;i<len;i++){
			total+=parseInt(document.getElementsByName(tradecode)[i].innerHTML);
		}
		console.log(total);
		//把總保費total指定給總保費欄位
		$('#instotal').val(total);
		//交易序號指定給交易序號欄位
		$('#tradecode').val(tradecode);
		
	}
	else{
	    //name叫做agreeChk1的全部都取消disabled
		$("input[name='ckb']").each(function(){
			$(this).prop("disabled",false);
		})
		//讓信用卡繳費disable
		$('#next').prop("disabled",true);
		//把總保費total清空
		$('#instotal').val("");
		//交易序號清空
		$('#tradecode').val("");
	}
	
}
---------------------------------------------------------------------
其他jquery寫法參考
$("#test").keyup(function(e){
		$(this).val($(this).val().toUpperCase());		
});

$("#test").change(function(){
	if($('#test :selected').text() == 'GOGORO')
	{
		$('#test').attr('checked', false);
		$('#test').attr("disabled", true);
	}
	else{
		$('#test').removeAttr("disabled");
	}
});

$("#test").blur(function(){
	
});	

---------------------------------------------------------------------
要新增全新功能，因此增加新的package(放在JavaSource/web)

com.asi.kyc.wb10.actions	//controller	WB10M0101.java
com.asi.kyc.wb10.models		//models(service) WB10M010m.java
com.asi.kyc.wb10.dao		//dao			  WB10M010Dao.java
com.asi.kyc.wb10.forms		//formbean		  WB10M010f.java


//view放在Webcontent -> web ->wb10(新)

WB10M010p1.jsp
WB10M010p2.jsp
WB10M010p3.jsp
WB10M010p4.jsp

//strust.config要加

<form-bean name="WB10M010f" type="com.asi.kyc.wb10.forms.WB10M010f" />

以及

<!-- 網投繳費服務 -->
<action path="/WB10M0101" name="WB10M010f"
	type="com.asi.kyc.wb10.actions.WB10M0101" scope="request" validate="false">
	<forward name="page1" path="neo_onlinelayout:/web/wb10/WB10M010p1.jsp" />
</action>


---------------------------------------------------------------------------------

MBC3PF由400抓資料的TABLE(第一頁要顯示的資料)

視BC382是否為Y( Y-繳費號碼-去PT85PF抓資料,其他為 保單號碼-去MEG1PF JOIN IC02PF抓資料) 以BC303為查詢條件  BC303即為繳費號碼或保單號碼

          繳費號碼(PT85PF)     保單號碼(IC02PF)
車牌      T8513                          C245
被保人    T8509                          C230
起保日    T8506                          C205


BC301(虛擬號碼、交易序號)
BC302(險別)
BC303(繳費號碼或保單號碼)
BC305(保費)  
BC306(繳費期限)
BC307(取消日期) SQL 條件 等於0代表沒被取消
BC371(客戶ID)：可由客戶登入後查到，當作SQL的where條件
BC308專案代號	當作SQL的where條件
BC384(收繳日期) 等於0即還未繳費 當作SQL的where條件

T8502(繳費號碼)
T8514(客戶ID) 被保人
T8527(要保人ID)
T8513(車牌號碼)
T8509(客戶名稱)
T8506(生效日、起保日)

C201(客戶ID) 被保人
C248(要保人ID)
C202(保單號碼)
C245(車牌號碼)
C230(被保人中文)
C205(保期-起)
C236(大險別)

G101   險別
G102   KEY值
G103   保單號碼
G111Y  生效日年
G111M  生效日月
G111D  生效日日

第二頁要判斷 
如勾選被保人本人  判斷被保人ID與持卡人ID是否符合  BC371
如勾選要保人  判斷要保人ID與持卡人ID是否符合  T8527 OR  C248

SQL：先用ID去MBC3PF找資料，再用FOR迴圈跑，判斷每筆的BC382是否為Y， Y -> PT85PF找車牌、被保人、起保日加入MAP裡 ，不是Y - > MEG1PF JOIN IC02PF找車牌、被保人、起保日加入MAP裡

select BC301,BC302,BC305,BC306,BC382,BC384,BC303,BC371 from MBC3PF
where BC371=? AND BC384=0 AND BC308=98 AND BC307 = 0
order by BC301,BC306; 

(if BC382=Y)
select T8513,T8509,T8506 from PT85PF where T8502=?(BC303)


不是Y - > MEG1PF JOIN IC02PF找車牌、被保人、起保日加入MAP裡
G102為KEY值，若此筆為批單則為批單號碼，若此筆為主保單則為保單號碼
因此若為批單，則會用他的主保單號碼G103以及險種G101去串IC02PF的保單資料，因此會有值
若為主保單則無此問題
也就是說：此筆若是批單我是用保單號碼去IC02PF找，此筆若是主保單我也是用保單號碼去IC02PF找，所以都串的到資料


(else)
select C245,C230,C205,G111Y,G111M,G111D from MEG1PF 
left join IC02PF on G103=C202 AND G101=C236
where G102=?(BC303)


--------------------------------------------------------------------------------------

HitrustUtil.java && WB8I083.java(振華寫的線上繳費功能) 可參考CALL HITRUST方式

callHitrustOwnerAuth()//持卡人驗證

callHitrustSSL()//直接取授權

第二頁，只要驗證持卡人ID有沒有亂打，然後將持卡人姓名、ID、記錄起來，並用 與被保人關係(被保本人OR要保人) 來檢核持卡人ID
等到第三頁確認繳費在送Hitrust驗證

***注意***
因這次需求是每次持卡人驗證都要送Hitrust驗證(每次都會收費)，所以只要用callHitrustOwnerAuth即可(這邊傳入的交易序號要另外產生不可與真正取授權的交易序號重複!!!)
但是真正的持卡人驗證應參考WB8I083.java(振華寫的線上繳費功能)

第一次驗證是送Hitrust驗證沒錯，但驗證成功後會將資料紀錄在ZS03PF
之後若是同樣的ID要再次驗證(第二次)，就是先去檢查ZS03PF的紀錄，若有存在就不須在送Hitrust驗證，直接驗證成功
這樣就不須一直送Hitrust驗證也就不用一直花錢
-----------------------------------------------------------------------------------------

信用卡繳費注意事項

1.要檢查卡號、到期年月、持卡ID驗證、取授權(第三頁確認線上繳費要做的事)

2.同一個交易序號可能會有多個且不同的保單號碼，也有可能是主保單與批單

如：

交易序號	保單號碼

TEST123		123		(可能是強制險)

TEST123		456		(可能是任意險)

但是可以一起繳費

請款是依刷卡後的金額(總金額)去分配解繳範例那兩筆


3.取得授權碼之後，請款只需要交易序號以及金額即可

PS：因Hitrust只提供正式環境的商店代號，因此測試時要先把Hiserver.conf的環境都改為正式才能測試成功(測試機要直接連回去改，只改LOCAL端沒用)，卡號也要用正是卡號
    待測試成功之後在將Hiserver.conf復原(正式CALL正式，測試CALL測試)，測試機後台系統參數也設回60214，只有正式機後台才是設為真正的80523
    
    ****  測試機上測試時要直接進測試機修改Hiserver.conf  ****


***要CALL HITRUST API 需要金鑰
C/Hitrust 記得放入 兩個金鑰	 80523.DER     PUB.DER
以及C:\HiTrust\testEnv  記得放入   PUB.DER

***要CALL HITRUST API 需要conf設定檔(該商店代號的設定檔)
80523.conf(對應商店代號)  放在javaSource -> com

***要CALL HITRUST API 需要確認HiServer.conf(設定CALL HITRUST的URL)正式OR測試

---------------------------------------------------------------------------------------

取授權後動作(DAO)

1.先找要寫入的資料
會有同樣BC301交易序號，不同BC303(保批單)的資料    BC372招攬人代號    BC371客戶ID    BC315通路代碼

select BC301,BC303,BC302,BC305,BC371,BC372,BC315 from MBC3PF  where BC301=?

2.UPDATE MBC3PF(BC309營業日期,BC310交易金額=BC305,BC384收繳日期)  更新時間(BC395)、記錄更新日期(BC398)、記錄更新人員(BC399) --> 更新MBC3PF的BC384後，之後就不會在撈到該筆交易序號

update (迴圈)看上面有幾筆
where BC301=? AND BC303=?

update MBC3PF set BC309=?,BC384=?,BC310=?,BC395,BC398,BC399 where BC301=? AND BC303=?;

3.INSERT PT15PF(T1501交易序號-同BC301,T1503險別-多筆時序編1,2……,T1504保單號碼-繳費號碼或保單號碼,T1578大險別-同BC302)  -->應該是請款時會用到

還有

新增信用卡(有遮罩)紀錄

//新增信用卡紀錄檔

寫PT15PF
紀錄 卡號隱碼 & 授權碼 & 當作KEY值的T1502 固定="FIRSTOL" 

T1532(卡號)  授權碼(T1579)
card1+card2(隱後兩碼)+card3(****)+card4

insert(迴圈)看上面有幾筆

//T1501交易序號-同BC301,T1502(固定寫FIRSTOL當作KEY值),T1503險別-多筆時序編1,2……,T1504保單號碼-繳費號碼或保單號碼-同BC303,          
//T1507(客戶ID-同BC371),T1520(招攬人-同BC372),T1523(交易日期),T1532(卡號),T1538(資料來源-固定OL),T1539&T1541(保費-同BC305),T1574(確認碼-固定X),T1578大險別-同BC302,T1579(授權碼)
//T15D6(取授權日期),T15D8(通路代碼-同BC315),T15E0(來源IP),T1594(建檔時間),T1595(異動時間),T1596(建檔日期),T1597(建檔者ＩＤ-BC371),T1598(修改日期),T1599(修改者ＩＤ-BC371)

insert into PT15PF(T1501,T1502,T1503,T1504,T1507,T1520,T1523,T1532,T1538,T1539,T1541,T1574,T1578,T1579,T15D6,T15D8,T15E0,T1594,T1595,T1596,T1597,T1598,T1599) 
values(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)

新增：取授權日期(T15D6)*  來源IP(T15E0)*  T1574(確認碼)=X*  T1523(交易日期)*  保費T1539.1541*  T1538資料來源(固定OL)*    T1507客戶ID*  T1520招攬人*  T15D8通路代碼*

建檔資料+一下(建檔人員=客戶ID) T1594建檔時間  T1595異動時間  T1596建檔日期   T1597建檔者ＩＤ   T1598修改日期   T1599修改者ＩＤ 


4.最後在判斷BC382為Y時才call fas22PRC 轉出單(更新PT85PF的動作)

第一次call是為上繳費狀態   "2" -> 修改，檢查預出單號碼尚未解繳時,  傳入暫收保費日 ->"0"  (此時還未傳入)
第二次傳暫收保費日並轉出單   "" -> 解繳成功後，轉入各險出單系統, 傳入暫收保費日 -> sysdate

取得授權碼之後，請款只需要交易序號以及金額即可


還差測試用的卡號以及商店代號 原本的：60214  新的：抓系統參數STOREID_OL(上正式機前要記得請CARTER新增)

SQL的商店代碼改為 80523 -> 
INSERT INTO "FIRSTCRM"."KYCKC" (KC01, KC02, KC03, CRTDT, CRTTM, CRTUR, UPDDT, UPDTM, UPDUR) VALUES ('STOREID_OL', '官網線上繳費HITRUST商店代碼', '80523', '1100728', '1100728', '47117', '1100728', '135307', 'FIRSTADMIN')


CALL HITRUST 取授權的方法 在新寫一個新的方法callHitrustSSL_OL(一樣在HitrustUtil裡)  因為有新的商店代號

